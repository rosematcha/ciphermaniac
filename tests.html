<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Unit Tests â€“ Ciphermaniac</title>
  <link rel="stylesheet" href="assets/style.css" />
  <style>
    body { padding: 16px; }
    .test-pass { color: #6ee7a8; }
    .test-fail { color: #ff6b6b; }
    pre { background:#0e111a; padding:10px; border-radius:8px; overflow:auto; }
  </style>
</head>
<body>
  <h1>Unit Tests</h1>
  <p>Open DevTools console for detailed logs. This page runs tiny browser-based tests for parse and sorting.</p>
  <ul id="results"></ul>

  <script type="module">
    import { parseReport } from './assets/js/parse.js';
  import { getComparator } from './assets/js/controls.js';
  import { computeLayout } from './assets/js/layoutHelper.js';
  import { getStateFromURL, planNormalizeIndexRoute, planNormalizeCardRoute } from './assets/js/router.js';
  import { isFavorite, setFavorite, getFavoritesSet } from './assets/js/favorites.js';
  import { pickArchetype } from './assets/js/selectArchetype.js';

    const results = document.getElementById('results');
    function record(name, ok, err){
      const li = document.createElement('li');
      li.textContent = (ok ? 'PASS: ' : 'FAIL: ') + name;
      li.className = ok ? 'test-pass' : 'test-fail';
      results.appendChild(li);
      if(err){
        const pre = document.createElement('pre');
        pre.textContent = String(err.stack || err);
        results.appendChild(pre);
      }
    }

    function test(name, fn){
      try{ fn(); record(name, true); }
      catch(e){ console.error('Test failed', name, e); record(name, false, e); }
    }

    // parse.js tests
    test('parseReport returns items/deckTotal from valid object', () => {
      const data = { deckTotal: 100, items: [{ name:'X', pct: 10 }] };
      const res = parseReport(data);
      if(res.deckTotal !== 100) throw new Error('deckTotal mismatch');
      if(!Array.isArray(res.items) || res.items.length !== 1) throw new Error('items mismatch');
    });

    test('parseReport throws on invalid input', () => {
      let threw = false;
      try{ parseReport({ hello: 'world' }); }
      catch{ threw = true; }
      if(!threw) throw new Error('expected throw');
    });

    // controls sorting tests
    test('getComparator percent-desc sorts by descending pct with nulls last', () => {
      const cmp = getComparator('percent-desc');
      const arr = [{ name:'B', pct: 5 }, { name:'A', pct: 10 }, { name:'C' }];
      arr.sort(cmp);
      const names = arr.map(x=>x.name).join(',');
      if(names !== 'A,B,C') throw new Error('got ' + names);
    });

    test('getComparator alpha-asc sorts by name A->Z', () => {
      const cmp = getComparator('alpha-asc');
      const arr = [{ name:'B' }, { name:'A' }, { name:'C' }];
      arr.sort(cmp);
      const names = arr.map(x=>x.name).join(',');
      if(names !== 'A,B,C') throw new Error('got ' + names);
    });

    // router tests
    test('getStateFromURL parses q/sort/archetype/tour/fav', () => {
      const fake = { search: '?q=Zard&sort=alpha-asc&archetype=Dragapult&tour=World%20Championships%202025&fav=fav' };
      const st = getStateFromURL(fake);
      if(st.q !== 'Zard') throw new Error('q mismatch');
      if(st.sort !== 'alpha-asc') throw new Error('sort mismatch');
      if(st.archetype !== 'Dragapult') throw new Error('archetype mismatch');
      if(st.tour !== 'World Championships 2025') throw new Error('tour mismatch');
      if(st.fav !== 'fav') throw new Error('fav mismatch');
    });
    // favorites smoke test (storage only)
    test('favorites storage toggles', () => {
      const before = new Set(getFavoritesSet());
      setFavorite('Test Card', true);
      if(!isFavorite('Test Card')) throw new Error('should be favorite');
      setFavorite('Test Card', false);
      if(isFavorite('Test Card')) throw new Error('should not be favorite');
      // restore
      for(const n of getFavoritesSet()) setFavorite(n, before.has(n));
    });

    test('getStateFromURL tolerates unknown params', () => {
      const st = getStateFromURL({ search: '?foo=bar' });
      if(st.q !== '' || st.sort !== '' || st.archetype !== '' || st.tour !== '') throw new Error('expected empty known fields');
    });

    // router plan helpers
    test('planNormalizeIndexRoute redirects #card/<name> to card.html', () => {
      const plan = planNormalizeIndexRoute({ pathname:'/index.html', search:'?q=abc', hash:'#card/Charizard' });
      if(!plan.redirect) throw new Error('expected redirect');
      if(!/card\.html\?q=abc#card\/Charizard$/.test(plan.url)) throw new Error('bad url ' + plan.url);
    });
    test('planNormalizeCardRoute redirects #grid to index.html#grid', () => {
      const plan = planNormalizeCardRoute({ pathname:'/card.html', search:'?tour=World', hash:'#grid' });
      if(!plan.redirect) throw new Error('expected redirect');
      if(plan.url !== '/index.html?tour=World#grid') throw new Error('bad url ' + plan.url);
    });

    test('getStateFromURL tolerates empty search', () => {
      const st = getStateFromURL({ search: '' });
      if(st.q !== '' || st.sort !== '' || st.archetype !== '' || st.tour !== '') throw new Error('expected empty fields');
    });

    // layoutHelper.js tests
    test('computeLayout returns expected big/small row counts and scales', () => {
      // Simulate a wide container
      const wide = computeLayout(1200);
      if(wide.perRowBig < 1) throw new Error('perRowBig too small');
      if(wide.bigRows !== 2) throw new Error('bigRows should be 2');
      if(wide.smallScale > 1 || wide.smallScale < 0.5) throw new Error('smallScale out of bounds');
      // Simulate a narrow container
      const narrow = computeLayout(300);
      if(narrow.base < 140) throw new Error('base too small');
      if(narrow.perRowBig < 1) throw new Error('perRowBig too small');
    });

    // pickArchetype tests
    test('pickArchetype returns highest pct when no Top 8 is provided', () => {
      const candidates = [
        { base: 'Arc_Fire', pct: 8.2, found: 2, total: 10 },
        { base: 'Mew_Box', pct: 12.5, found: 5, total: 40 },
        { base: 'Lost_Box', pct: 10.1, found: 3, total: 30 }
      ];
      const chosen = pickArchetype(candidates);
      if(!chosen || chosen.base !== 'Mew_Box') throw new Error('expected highest pct Mew_Box');
    });

    test('pickArchetype favors larger found when pct is tied', () => {
      const candidates = [
        { base: 'Blissey', pct: 100, found: 1, total: 1 },
        { base: 'Dragapult_Dusknoir', pct: 100, found: 21, total: 21 }
      ];
      const chosen = pickArchetype(candidates);
      if(!chosen || chosen.base !== 'Dragapult_Dusknoir') throw new Error('expected Dragapult_Dusknoir due to larger sample');
    });

    test('pickArchetype still respects Top 8 constraint', () => {
      const candidates = [
        { base: 'Blissey', pct: 100, found: 1, total: 1 },
        { base: 'Dragapult_Dusknoir', pct: 95, found: 20, total: 21 },
        { base: 'Gardevoir', pct: 40, found: 10, total: 25 }
      ];
      const chosen = pickArchetype(candidates, ['Gardevoir']);
      if(!chosen || chosen.base !== 'Gardevoir') throw new Error('expected Gardevoir from Top 8 list');
    });

    // new router tests
    import { normalizeUnknownHashOnIndex, setStateInURL } from './assets/js/router.js';
  import { parseHash, stringifyRoute } from './assets/js/router.js';

    test('normalizeUnknownHashOnIndex clears unknown hash', () => {
      // Simulate presence of unknown hash by calling the function directly; it uses location.
      // We can't fully fake location in a unit test environment, so at minimum call it to ensure it exists and returns a boolean.
      const res = typeof normalizeUnknownHashOnIndex === 'function';
      if(!res) throw new Error('normalizeUnknownHashOnIndex missing');
    });

    test('setStateInURL merge/replace builds URLs without throwing', () => {
      const fn = typeof setStateInURL === 'function';
      if(!fn) throw new Error('setStateInURL missing');
    });

    test('parseHash/stringifyRoute roundtrip for card route', () => {
      const p = parseHash('#card/Charizard');
      if(p.route !== 'card' || p.name !== 'Charizard') throw new Error('parseHash failed');
      const s = stringifyRoute(p);
      if(s !== '#card/Charizard') throw new Error('stringifyRoute failed: ' + s);
    });
  </script>
</body>
</html>
